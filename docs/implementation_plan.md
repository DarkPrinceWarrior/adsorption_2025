## План внедрения улучшений

Документ фиксирует наблюдаемые проблемы между текущим кодом и теоретическими требованиями из `docs/`. Каждая секция описывает:

- **Проблему** — что именно не работает или отсутствует.
- **Почему она возникла** — ссылки на код и артефакты.
- **Решение** — конкретные шаги, которые нужно выполнить при реализации.

### 1. База молярных масс и нитратных гидратов

- **Проблема:** функции `_update_stoichiometry_features` и `_project_stoichiometry` требуют колонок `Молярка_соли` и `Молярка_кислоты`, но загрузчик данных их нигде не создаёт. В результате стехиометрия либо не считается, либо полагается на заранее подготовленные CSV. Это расходится с `docs/molar_masses_nitrates.py`, где перечислены точные массы.
- **Почему:** `build_lookup_tables` копирует значения «как есть» из исходного CSV, а фиктивная колонка с молярной массой отсутствует; в `add_salt_mass_features` нет расчётов.
- **Решение:** вынести словари из `docs/molar_masses_nitrates.py` в новый модуль `src/adsorb_synthesis/molar_masses.py`, добавить helper `add_molar_mass_columns(df)` и вызывать его в `load_dataset` до построения lookup-таблиц. Нужен fallback: если для металла нет гидрата в справочнике, использовать безводную соль и писать warning. Покрыть тестом.

### 2. Стехиометрия MOF должна учитывать тип материала

- **Проблема:** `_project_stoichiometry` сейчас просто клипает `n_ratio` в фиксированные границы `(0.45, 2.3)` — это игнорирует химические стехиометрии (HKUST-1 = 1.5, MOF‑5 = 2.0, см. `docs/CHEATSHEET_formulas.txt`). Следовательно, модель может выдавать невозможные соотношения.
- **Почему:** в `constants.py` закреплено единое `N_RATIO_BOUNDS`, а таблица теоретических коэффициентов отсутствует.
- **Решение:** создать карту `STOICHIOMETRY_TARGETS = {(metal, ligand): (ratio, tolerance)}` (см. `docs/molar_masses_nitrates.py`). В `_project_stoichiometry` и валидаторе данных получать целевой диапазон из этой карты; корректировать массу кислоты так, чтобы `n_ratio` приближался к целевому отношению. Для неизвестных комбинаций использовать прежние широкие границы, но логгировать предупреждение.

### 3. Feature engineering должен соответствовать шпаргалке

- **Проблема:** в `add_salt_mass_features` добавляются лишь «Metal_Ligand_Combo», `Log_Metal_MW`, индикаторы Cu/Zn и `log_salt_mass`. Отсутствуют концентрации, мольные соотношения, температурные диапазоны и проверочные признаки из раздела V шпаргалки.
- **Почему:** инженерные признаки не обновлялись после появления новых идей в `docs/CHEATSHEET_formulas.txt` и `docs/exact_formulas_for_nn.py`.
- **Решение:** расширить функцию, чтобы она считала:
  - `C_metal`, `C_ligand`, `log_C_metal`, `log_C_ligand`
  - `R_mass`, `R_molar` (используя молярные массы из пункта 1)
  - `T_range`, `T_activation = T_reg - 100`, `T_dry_norm`
  - `a0_calc`, `E_calc`, `Ws_W0_ratio`, `SBET_calc`, `E_E0_ratio`
  - вдобавок сохранять `delta_a0`, `delta_E`, `delta_Ws` (для весов/логов).
  Все новые признаки нужно включить в соответствующие списки `feature_columns` стадий. Добавить тест, проверяющий наличие колонок.

### 4. Валидация входных данных и режимы строгого/мягкого контроля

- **Проблема:** pipeline принимает экспериментальные СЭХ без проверок, хотя `docs/exact_formulas_for_nn.py` рекомендует убедиться в точных равенствах и температурных ограничениях до обучения.
- **Почему:** в `load_dataset` отсутствует вызов валидаторов; ошибки обнаруживаются поздно или вообще не замечаются.
- **Решение:** реализовать модуль `data_validation.py` с функциями:
  - `validate_SEH_data(df, mode='warn'|'strict')` — проверяет `a0`, `E`, `Ws`, `S_BET` против расчётных значений, возвращает отчёт и/или выбрасывает `ValueError`.
  - `validate_synthesis_data(df, boiling_points, mode=...)` — проверяет массы, объёмы, температурный порядок и `T_syn < T_boiling(solvent)`.
  В `load_dataset` вызывать их после расчёта производных признаков; режим задавать аргументом CLI. Логи должны содержать номера строк и величину отклонения.

### 5. Расширение physics evaluator: равенства и неравенства

- **Проблема:** `PhysicsConstraintEvaluator` учитывает только диапазоны `E0` и `Adsorption_Energy_Ratio` плюс термодинамику. Ключевые связи (`a0 = 28.86·W0`, `E = E0/3`, `Ws ≥ W0`) вообще не контролируются, поэтому sample weights слабо отражают физику.
- **Почему:** класс содержит только `BoundConstraint` и `ThermodynamicConstraint`, новых типов нет.
- **Решение:** добавить типы:
  - `EqualityConstraint(column_a, column_b, coefficient, tolerance)` для точных линейных зависимостей.
  - `RatioConstraint(column_a, column_b, target_ratio, tolerance)` для выражений типа `E/E0 = 1/3`.
  - `InequalityConstraint(column_left, column_right, operator)` для `Ws ≥ W0`.
  Обновить `physics_violation_scores` и `DEFAULT_PHYSICS_EVALUATOR`, чтобы они учитывали новые штрафы. Эти значения использовать исключительно для sample weighting и отчётности (не изменять входные данные).

### 6. Пост-обработка предсказаний и температурные ограничения

- **Проблема:** `_project_stoichiometry`, `project_thermodynamics` и `_enforce_temperature_order` работают, но: (1) они не используют новые точные диапазоны из пункта 2; (2) нигде не проверяется `T_syn < T_boiling(solvent)` при инференсе; (3) отсутствует численное представление температур, поэтому сравнение категорий не гарантирует соблюдения физических лимитов.
- **Почему:** изначально планировалось, что данные уже очищены и растворитель фиксирован (ДМФА).
- **Решение:** 
  - После внедрения стехиометрической карты переписать `_project_stoichiometry` с учётом конкретных целевых соотношений.
  - Добавить `_enforce_temperature_limits(df)` — функция переводит категорию в representative value (например, среднее бина) и проверяет неравенства, а также `T_syn` против `T_boiling[solvent]`. При нарушениях: логировать и корректировать к ближайшему допустимому значению.
  - Рассмотреть добавление регрессионных стадий для численных температур, чтобы уменьшить неопределённость.

### 7. StageConfig и обратные преобразования таргетов

- **Проблема:** в `pipeline.predict` и `fit` лог-преобразование распознано через жёсткую проверку `stage.target == "log_salt_mass"`. При появлении новых трансформов придётся копировать логику вручную.
- **Почему:** в `StageConfig` отсутствует информация о трансформациях.
- **Решение:** добавить поля `target_transform` (`None | 'log1p' | ...`) и `invert_to` (имя столбца с обратным преобразованием). При обучении и инференсе применять трансформу централизованно, убрать `if stage.target == "log_salt_mass"`. Учесть это в сохранении метаданных и загрузке.

### 8. Корректное применение physics weights в моделях

- **Проблема:** 
  1. `_compute_physics_sample_weights` в `ModernTabularEnsemble*` вызывает `physics_loss_fn` для каждого экземпляра отдельно, что создаёт n DataFrame и вычисляет средний loss вместо вектора — медленно и неинформативно.
  2. При наличии sample weights TabNet вовсе не обучается (`if w_train is None: ...`).
  3. Penalizing происходит на исходных признаках до `ColumnTransformer`, что не влияет на табличные модели после one-hot.
- **Почему:** изначальная версия строилась на предположении, что `physics_loss_fn` возвращает уже готовый скаляр.
- **Решение:** 
  - Изменить интерфейс `physics_loss_fn` так, чтобы он принимал массив и возвращал per-sample вектор (можно использовать `PhysicsConstraintEvaluator.penalties`).
  - Передавать sample weights в TabNet (`fit(..., weights=w_train)`).
  - Для вычисления штрафов использовать специально подготовленный DataFrame с необходимыми физическими колонками (можно формировать до трансформаций, но обязательно включать engineered признаки из пункта 3).

### 9. Пересмотр генерации термодинамических признаков

- **Проблема:** `_ensure_adsorption_features` заново вычисляет `K_equilibrium` и `Delta_G`, предполагая температуру 298.15 K, хотя реальные значения зависят от `Т.син., °С`. Это может искажать данные и штрафы.
- **Почему:** блок написан для случая, когда в исходном CSV вообще нет колонок K_eq/ΔG.
- **Решение:** 
  - Если измеренные `K_equilibrium` или `Delta_G` отсутствуют, вычислять их после того, как известна реальная температура синтеза (или хотя бы использовать фактическую колонку `Т.син., °С` вместо константы).
  - В `add_thermodynamic_features` отдельно сохранять «пересчитанные» колонки (например, `K_equilibrium_from_delta_G`), чтобы не затирать оригинальные значения.

### 10. Тестовое покрытие

- **Проблема:** текущие тесты не проверяют валидатор, стехиометрию и работу physics evaluator.
- **Почему:** focus был на smoke-тестах.
- **Решение:** добавить тесты:
  - `test_molar_masses.py` — правильность расчёта молярных масс и R_molar.
  - `test_data_validation.py` — выброс ошибок/предупреждений для некорректных СЭХ и температур.
  - `test_stoichiometry_projection.py` — корректировка `m(кис-ты)` к целевому ratio.
  - `test_physics_evaluator.py` — равенства и неравенства дают нулевой штраф на консистентных данных.

---

Эта дорожная карта должна использоваться как основа для последовательной реализации. Каждый пункт можно оформлять отдельным коммитом или PR, сохраняя трассировку между проблемой и решением.
